### Eclipse Workspace Patch 1.0
#P org.eclipse.equinox.executable
Index: library/eclipseMain.c
===================================================================
RCS file: /cvsroot/rt/org.eclipse.equinox/framework/bundles/org.eclipse.equinox.executable/library/eclipseMain.c,v
retrieving revision 1.28
diff -u -r1.28 eclipseMain.c
--- library/eclipseMain.c	14 Dec 2009 19:17:52 -0000	1.28
+++ library/eclipseMain.c	22 Feb 2010 18:36:39 -0000
@@ -20,6 +20,15 @@
 #include <ctype.h>
 #include <locale.h>
 #include <sys/stat.h>
+#ifdef MACOSX
+#include <CoreServices/CoreServices.h>
+#ifdef COCOA
+#include <Cocoa/Cocoa.h>
+#else
+#include <Carbon/Carbon.h>
+#endif
+#endif
+#include <pthread.h>
 
 static _TCHAR* libraryMsg =
 _T_ECLIPSE("The %s executable launcher was unable to locate its \n\
@@ -34,17 +43,20 @@
 /* New arguments have the form --launcher.<arg> to avoid collisions */
 #define LIBRARY		  _T_ECLIPSE("--launcher.library")
 #define SUPRESSERRORS _T_ECLIPSE("--launcher.suppressErrors")
+#define SECOND_THREAD _T_ECLIPSE("--launcher.secondThread")
 #define INI			  _T_ECLIPSE("--launcher.ini")
 
 /* this typedef must match the run method in eclipse.c */
 typedef int (*RunMethod)(int argc, _TCHAR* argv[], _TCHAR* vmArgs[]);
 typedef void (*SetInitialArgs)(int argc, _TCHAR*argv[], _TCHAR* library);
 
+static _TCHAR*  program 	  = NULL;			/* program path */
 static _TCHAR*  name          = NULL;			/* program name */
 static _TCHAR** userVMarg     = NULL;     		/* user specific args for the Java VM  */
 static _TCHAR*  programDir	  = NULL;			/* directory where program resides */
 static _TCHAR*  officialName  = NULL;
 static int      suppressErrors = 0;				/* supress error dialogs */
+       int     secondThread  = 0;				/* True: start the VM on a second thread */
 
 static int 	 	createUserArgs(int configArgc, _TCHAR **configArgv, int *argc, _TCHAR ***argv);
 static void  	parseArgs( int* argc, _TCHAR* argv[] );
@@ -90,18 +102,55 @@
 #define main mainW
 #endif /* UNICODE */
 
+static void dispose(void) {
+	free( eclipseLibrary );
+    free( programDir );
+    free( program );
+    free( officialName );
+}
+
+#ifdef MACOSX
+typedef struct {
+	int argc;
+	_TCHAR** argv;	
+	_TCHAR** userVMarg;
+	void* handle;
+} ThreadArgs;
+
+static void * startThread(void * init) {
+	ThreadArgs * args = (ThreadArgs *) init;
+	RunMethod runMethod = (RunMethod)findSymbol(args->handle, RUN_METHOD);
+	if(runMethod != NULL) {
+		int exitCode = runMethod(args->argc, args->argv, args->userVMarg);
+		unloadLibrary(args->handle);
+		dispose();
+		exit(exitCode);
+	}
+	else { 
+		if(!suppressErrors)
+			displayMessage(officialName, entryMsg);
+		else 
+			_ftprintf(stderr, _T_ECLIPSE("%s:\n%s\n"), officialName, entryMsg);
+		exit(1);
+	}
+	return NULL;
+}
+#endif
+
+#ifdef MACOSX
+static void dummyCallback(void * info) {}
+#endif
+
 int main( int argc, _TCHAR* argv[] )
 {
 	_TCHAR*  errorMsg;
-	_TCHAR*  program;
 	_TCHAR*  iniFile;
 	_TCHAR*  ch;
 	_TCHAR** configArgv = NULL;
 	int 	 configArgc = 0;
 	int      exitCode = 0;
 	int      ret = 0;
-	void *	 handle = 0;
-	RunMethod 		runMethod;
+	void*	 handle = NULL;
 	SetInitialArgs  setArgs;
 	
 	setlocale(LC_ALL, "");
@@ -181,7 +230,73 @@
 		exit(1);
 	}
 	
-	runMethod = (RunMethod)findSymbol(handle, RUN_METHOD);
+#ifdef MACOSX
+	/* if --launcher.secondThread was specified, create a new thread and run the vm on it.  
+	 * This main thread will run the CFRunLoop 
+	 */
+	if (secondThread != 0) {
+		/* Initialize the application */
+		#ifdef COCOA
+		[NSApplication sharedApplication];
+		#else
+		ClearMenuBar();
+		#endif
+		
+		/* Create and run the sencond thread */
+		struct rlimit limit = {0, 0};
+		int stackSize = 0;
+		if (getrlimit(RLIMIT_STACK, &limit) == 0) {
+			if (limit.rlim_cur != 0) {
+				stackSize = limit.rlim_cur;
+			}
+		}
+		void *status;
+		pthread_t thread;
+		pthread_attr_t attributes;
+		pthread_attr_init(&attributes);
+		pthread_attr_setscope(&attributes, PTHREAD_SCOPE_SYSTEM);
+		pthread_attr_setdetachstate(&attributes, PTHREAD_CREATE_DETACHED);
+		if (stackSize != 0)
+			pthread_attr_setstacksize(&attributes, stackSize);
+		
+		CFRunLoopSourceContext sourceContext = { 
+			.version = 0, .info = NULL, .retain = NULL, .release = NULL,
+			.copyDescription = NULL, .equal = NULL, .hash = NULL, 
+			.schedule = NULL, .cancel = NULL, .perform = &dummyCallback 
+		};
+		
+		CFRunLoopSourceRef sourceRef = CFRunLoopSourceCreate(NULL, 0, &sourceContext);
+		CFRunLoopAddSource(CFRunLoopGetCurrent(), sourceRef, kCFRunLoopCommonModes);
+		
+		ThreadArgs threadArgs;
+		threadArgs.argc = argc;
+		threadArgs.argv = argv;
+		threadArgs.userVMarg = userVMarg;
+		threadArgs.handle = handle;
+		pthread_create( &thread, &attributes, &startThread, &threadArgs);
+		pthread_attr_destroy(&attributes);
+		
+		CFRunLoopRun();	
+		CFRelease(sourceRef);
+
+		pthread_join(thread, &status);
+	} else {
+		RunMethod runMethod = (RunMethod)findSymbol(handle, RUN_METHOD);
+		if(runMethod != NULL)
+			exitCode = runMethod(argc, argv, userVMarg);
+		else { 
+			if(!suppressErrors)
+				displayMessage(officialName, entryMsg);
+			else 
+				_ftprintf(stderr, _T_ECLIPSE("%s:\n%s\n"), officialName, entryMsg);
+			exit(1);
+		}
+		
+		unloadLibrary(handle);
+		dispose();
+	}
+#else
+	RunMethod runMethod = (RunMethod)findSymbol(handle, RUN_METHOD);
 	if(runMethod != NULL)
 		exitCode = runMethod(argc, argv, userVMarg);
 	else { 
@@ -191,12 +306,10 @@
 			_ftprintf(stderr, _T_ECLIPSE("%s:\n%s\n"), officialName, entryMsg);
 		exit(1);
 	}
-	unloadLibrary(handle);
 	
-	free( eclipseLibrary );
-    free( programDir );
-    free( program );
-    free( officialName );
+	unloadLibrary(handle);
+	dispose();
+#endif	
     
 	return exitCode;
 }
@@ -261,6 +374,8 @@
         	eclipseLibrary = argv[++index];
         } else if(_tcsicmp(argv[index], SUPRESSERRORS) == 0) {
         	suppressErrors = 1;
+        } else if(_tcsicmp(argv[index], SECOND_THREAD) == 0) {
+        	secondThread = 1;
         } 
     }
 }
Index: library/carbon/eclipseCarbon.c
===================================================================
RCS file: /cvsroot/rt/org.eclipse.equinox/framework/bundles/org.eclipse.equinox.executable/library/carbon/eclipseCarbon.c,v
retrieving revision 1.31
diff -u -r1.31 eclipseCarbon.c
--- library/carbon/eclipseCarbon.c	8 Feb 2010 20:58:29 -0000	1.31
+++ library/carbon/eclipseCarbon.c	22 Feb 2010 18:36:39 -0000
@@ -73,15 +73,6 @@
 /* Define the window system arguments for the various Java VMs. */
 static char*  argVM_JAVA[] = { "-XstartOnFirstThread", NULL };
 
-/* thread stuff */
-typedef struct {
-	_TCHAR * libPath;
-	_TCHAR ** vmArgs;
-	_TCHAR ** progArgs;
-	_TCHAR * jarFile;
-	JavaResults* result;
-} StartVMArgs;
-
 #ifdef COCOA
 static NSWindow* window = nil;
 @interface KeyWindow : NSWindow { }
@@ -151,10 +142,6 @@
 @end
 #endif
 
-static CFRunLoopRef loopRef = NULL;
-static void * startThread(void * init); 
-static void runEventLoop(CFRunLoopRef ref);
-static void dummyCallback(void * info) {}
 #ifndef COCOA
 static CFMutableArrayRef files;
 static EventHandlerRef appHandler;
@@ -169,7 +156,7 @@
 
 void installAppleEventHandler();
 
-int reuseWorkbench(_TCHAR** filePath, int timeout) {
+int reuseWorkbench(_TCHAR* filePath, int timeout) {
 	installAppleEventHandler();
 	return 0;
 }
@@ -635,64 +622,9 @@
 		char firstThreadEnvVariable[80];
 		sprintf(firstThreadEnvVariable, "JAVA_STARTED_ON_FIRST_THREAD_%d", getpid());
 		setenv(firstThreadEnvVariable, "1", 1);
-		return startJavaJNI(libPath, vmArgs, progArgs, jarFile);
-	}
-
-	/* else, --launcher.secondThread was specified, create a new thread and run the 
-	 * vm on it.  This main thread will run the CFRunLoop 
-	 */
-	pthread_t thread;
-	struct rlimit limit = {0, 0};
-	int stackSize = 0;
-	if (getrlimit(RLIMIT_STACK, &limit) == 0) {
-		if (limit.rlim_cur != 0) {
-			stackSize = limit.rlim_cur;
-		}
 	}
-	
-	/* initialize thread attributes */
-	pthread_attr_t attributes;
-	pthread_attr_init(&attributes);
-	pthread_attr_setscope(&attributes, PTHREAD_SCOPE_SYSTEM);
-	pthread_attr_setdetachstate(&attributes, PTHREAD_CREATE_DETACHED);
-	if (stackSize != 0)
-		pthread_attr_setstacksize(&attributes, stackSize);
-	
-	/* arguments to start the vm */
-	StartVMArgs args;
-	args.libPath = libPath;
-	args.vmArgs = vmArgs;
-	args.progArgs = progArgs;
-	args.jarFile = jarFile;
-	args.result = 0;
-	
-	loopRef = CFRunLoopGetCurrent();
-	
-	/* create the thread */
-	pthread_create( &thread, &attributes, &startThread, &args);
-	pthread_attr_destroy(&attributes);
-		
-	runEventLoop(loopRef);
-	
-	return args.result;
-}
-
-void * startThread(void * init) {
-	StartVMArgs *args = (StartVMArgs *) init;
-	args->result = startJavaJNI(args->libPath, args->vmArgs, args->progArgs, args->jarFile);
-	return NULL;
-}
-
-void runEventLoop(CFRunLoopRef ref) {
-	CFRunLoopSourceContext sourceContext = { .version = 0, .info = NULL, .retain = NULL, .release = NULL,
-											 .copyDescription = NULL, .equal = NULL, .hash = NULL, 
-											 .schedule = NULL, .cancel = NULL, .perform = &dummyCallback };
-	
-	CFRunLoopSourceRef sourceRef = CFRunLoopSourceCreate(NULL, 0, &sourceContext);
-	CFRunLoopAddSource(ref, sourceRef,  kCFRunLoopCommonModes);
-	
-	CFRunLoopRun();
-	CFRelease(sourceRef);
+	JavaResults* results = startJavaJNI(libPath, vmArgs, progArgs, jarFile);
+	return results;
 }
 
 #ifndef COCOA
